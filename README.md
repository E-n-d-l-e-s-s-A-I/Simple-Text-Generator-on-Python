Приложение предоставляет инструмент для генерации продолжения фраз на основе начальных слов, введенных пользователем. Процесс генерации осуществляется на основе словарей, созданных из загруженных текстовых файлов, которые анализируются и сохраняют последовательности слов для предсказания наиболее вероятных последующих слов.

## Оглавление
1. [Установка](#установка)
2. [Используемые технологии](#используемые-технологии)
3. [Функциональные возможности](#функциональные-возможности)
4. [Использование](#использование)
5. [Алгоритм генерации](#алгоритм-генерации)
6. [Архитектура приложения](#архитектура-приложения)
7. [Производительность](#производительность)

## Установка


## Функциональные возможности

- **Генерация продолжения фраз**: Генерация продолжения фразы на основе начальных слов, введенных пользователем, с использованием словарей, созданных из загруженных текстов.

- **Управление словарями**:
  - **Сохранение словарей**: Сохранение сгенерированных словарей для дальнейшего использования.
  - **Дополнение словарей**: Добавление новых последовательностей слов в существующий словарь путем загрузки дополнительных текстовых файлов.
  - **Удаление словарей**: Удаление словарей, когда они больше не нужны.
  - **Генерация текста**: Генерация продолжения текста на основе выбранного словаря.

- **Настройки генерации**:
  - **`max_generated_word_count`**: Устанавливает максимальное количество слов, которые генератор добавит к исходной фразе.
  - **`generated_without_dot`**: Определяет количество слов, после которого генератор попытается завершить предложение.

- **Конфигурация**:
  - Приложение позволяет изменять настройки генерации через файл `config.txt`.


## Использование

1. **Загрузка текста**: Загрузите текстовый файл для создания словаря, который приложение будет использовать для генерации фраз.
2. **Управление словарями**: Дополняйте или удаляйте словари в зависимости от необходимости обновления или поддержания моделей генерации.
3. **Генерация текста**: Введите начальные слова фразы, и приложение сгенерирует продолжение на основе выбранного словаря и текущих настроек.
4. **Настройка параметров**: Измените файл `config.txt`, чтобы настроить параметры `max_generated_word_count` и `generated_without_dot` в соответствии с вашими потребностями.

Интерфейс приложения


## Алгоритм генерации

Основой работы алгоритма генерации текста является использование n-грамм — последовательностей из n слов, извлечённых из текста. 1-граммы называют униграммами, 2-граммы называют биграммами, 3-граммы — триграммами. n-граммы позволяют прогнозировать следующее слово на основе предыдущих одного или двух слов.
#### Примеры n-грамм:

Рассмотрим фразу: **"мама мыла раму и кошку"**.
- Униграммы:
  - "мама"
  - "мыла"
  - "раму"
  - "и"
  - "кошку"

- Биграммы:
  - "мама мыла"
  - "мыла раму"
  - "раму и"
  - "и кошку"

- Триграммы:
  - "мама мыла раму"
  - "мыла раму и"
  - "раму и кошку"

### Алгоритм
1. **Анализ текста и создание словаря**:
    - **Разбиение текста на слова и предложения.** Разделителями предложений являются символы ".", "!", "?", ";", "(", ")". Словом считается последовательность символов кирилицы, латиницы, запятых и двоеточий. Все остальные символы в предложении игнорируются. В конце предложения в приказном порядке ставится точка, которая рассматривается как его последнее слово.
    - **Разбиение каждого приложения на униграммы и биграммы.** Униграммы представляют собой отдельные слова, биграммы — последовательности из двух слов.
    - **Создание частотного словаря.** Для каждой униграммы и биграммы составляется частотный словарь, содержащий все возможные, слова которые следовали за n-граммой, и их количество.
    - **Выбор самых частых продолжений.** По частотному словарю составляется список из двух самых частых продолжений, при одинаковом количестве слов, приоритет отдается лексикографически меньшему слову.

2. **Генерация продолжения фразы**:
    - Пользователь вводит начальные слова фразы.
    - Алгоритм ищет в словаре униграммы или биграммы, совпадающие с последними одним или двумя словами введённой фразы.
    - Если найдена подходящая биграмма, следующее слово выбирается на основе этой биграммы. Если биграмма не найдена, используется униграммва.
    - Из списка двух самых частых продолжений n-граммы выбирается случайное продолжение, но предпочтение отдается точке, если уже достигнуто `generated_without_dot` слов, и не точке в обратном случае.
    - Этот процесс повторяется до тех пор, пока не будет добавлено максимальное количество слов (на основе настройки `max_generated_word_count`), или не будет достигнута точка, или в словаре не будет подходящей биграммы и униграммы.

### Пример генерации:

Предположим, что у нас есть следующий текст для анализа:

`котик играет с мышкой, котик ест еду: котик спит.`

Частотный словарь будет содержать:

Униграммы

{

    "котик": {"играет": 1, "ест": 1, "спит": 1},

    "играет": {"с": 1},

    "с": {"мышкой,": 1},

    "мышкой,": {"котик": 1},

    "ест": {"еду:": 1},

    "еду:": {"котик": 1},

    "спит": {".": 1}

}

Биграммы

{

    "котик играет": {"с": 1},

    "играет с": {"мышкой,": 1},

    "с мышкой,": {"котик": 1},

    "котик ест": {"еду:": 1},

    "ест еду:": {"котик": 1},

    "котик спит": {".": 1}

}

Список самых частых продолжений будет выглядеть:

    "котик": ["ест", "играет"]

    "играет": ["с"]

    "с": ["мышкой,"]

    "мышкой,": ["котик"]

    "ест": ["еду:"]

    "еду:": ["котик"]

    "спит": ["."]

    "котик играет": ["с"]

    "играет с": ["мышкой,"]

    "с мышкой,": ["котик"]

    "котик ест": ["еду:"]

    "ест еду:": ["котик"]

    "котик спит": ["."]

Теперь если пользователь введет слово "котик":

(Для упрощения примера опустим параметры: `generated_without_dot` и `max_generated_word_count`, их влияние очевидно из описания алгоритма)


#### Шаг 1: Введена фраза `"котик"`

- Алгоритм находит униграмму `"котик"` в словаре униграмм.
- Возможные продолжения: `["ест", "играет"]`.
- Предположим, случайно выбирается `"играет"`.

#### Шаг 2: Фраза теперь выглядит так: `"котик играет"`

- Алгоритм находит биграмму `"котик играет"` в словаре биграмм.
- Возможное продолжение: `"с"`.

#### Шаг 3: Фраза теперь выглядит так: `"котик играет с"`

- Алгоритм находит биграмму `"играет с"` в словаре биграмм.
- Возможное продолжение: `"мышкой,"`.

#### Шаг 4: Фраза теперь выглядит так: `"котик играет с мышкой,"`

- Алгоритм находит биграмму `"с мышкой,"` в словаре биграмм.
- Возможное продолжение: `"котик"`.

#### Шаг 5: Фраза теперь выглядит так: `"котик играет с мышкой, котик"`

- Алгоритм снова находит униграмму `"котик"` в словаре униграмм.
- Возможные продолжения: `["ест", "играет"]`. Предположим, случайно выбирается `"ест"`.

#### Шаг 6: Фраза теперь выглядит так: `"котик играет с мышкой, котик ест"`

- Алгоритм находит биграмму `"котик ест"` в словаре биграмм.
- Возможное продолжение: `"еду:"`.

#### Шаг 7: Фраза теперь выглядит так: `"котик играет с мышкой, котик ест еду:"`

- Алгоритм находит биграмму `"ест еду:"` в словаре биграмм.
- Возможное продолжение: `"котик"`.

#### Шаг 8: Фраза теперь выглядит так: `"котик играет с мышкой, котик ест еду: котик"`

- Алгоритм снова находит униграмму `"котик"` в словаре униграмм.
- Возможные продолжения: `["ест", "играет"]`. Предположим, случайно выбирается `"играет"`.

#### Итог: Сгенерированная фраза
`котик играет с мышкой, котик ест еду: котик играет`
#### Если на первом шаге, было бы выбрано продолжение `"ест"`, была бы получена фраза:
`котик ест еду: котик `
## Архитектура приложения
## Производительность